#!/usr/bin/env bash
# Script assembled and exported by:
#     ___ ___  ___  ____ ____  ___ __ __
#    / __/ _ \/ _ |/ ___/ __/ / __/ // /
#   _\ \/ ___/ __ / /__/ _/_ _\ \/ _  /
#  /___/_/  /_/ |_\___/___(_)___/_//_/
#  version: 1.4.0 | https://space.sh
#
# Node: /cmdline/
# Use podc as a standalone cmd line tool

set -u  # Will not allow for unset variables being used.

_YAML_PREFIX="_sg"
_YAML_NAMESPACE="1"
_SPACEGAL_EOF_TAG="_SPACEGAL_SAYS_END_OF_FINITY_"
SPACE_LOG_LEVEL="${SPACE_LOG_LEVEL:-4}"
SPACE_LOG_ENABLE_COLORS="${SPACE_LOG_ENABLE_COLORS:-1}"
SPACE_ASSERT_EXIT="${SPACE_ASSERT_EXIT:-0}"
SPACE_MUTE_EXIT="${SPACE_MUTE_EXIT:-0}"
SPACE_MUTE_EXIT_MESSAGE="${SPACE_MUTE_EXIT_MESSAGE:-1}"
PODC_CMDLINE()
{
    local _SPACE_NAME="PODC_CMDLINE"

    local _out_rest=""
    local _out_h="false"
    local _out_V="false"
    local _out_p="true"

    local _out_f=""
    local _out_o=""
    local _out_d=""

    if ! _GETOPTS "h V" "f o d p" 0 1 "$@"; then
        printf "Usage: pod [podname] [-f infile] [-o outfile] [-d srcdir] [-p true|false]\\n" >&2
        return 1
    fi

    if [ "${_out_h}" = "true" ]; then
        USAGE
        return
    fi

    if [ "${_out_V}" = "true" ]; then
        VERSION
        return
    fi

    COMPILE_ENTRY "${_out_rest}" "${_out_f}" "${_out_o}" "${_out_d}" "${_out_p}"
}

USAGE()
{
    local _SPACE_NAME="USAGE"
    printf "%s\\n" "Usage:

    podc -h
        Output this help

    podc -V
        Output version

    podc [podname] [-f infile] [-o outfile] [-d srcdir] [-p]

        podname
            is the name of the pod, default is to take the directory name,
            but which might not be a valid name. Only a-z0-9 and underscore allowed.
            Must start with a letter.

        -f infile
            optional path to the pod.yaml file.
            Default is to look for pod.yaml in the current directory.

        -o outfile
            optional path where to write the executable pod file.
            Default is \"pod\" in the same directory as the pod yaml file.

        -p true|false (default true)
            optional flag do perform preprocessing on the pod.yaml file or not.

        -d srcdir
            Optional directory path to use as source directory if \"infile\"
            is in another directory.
            This feature is used by other tools who do preprocessing
            on the original pod.yaml file and place a temporary file elsewhere.
            It can also be used to override the home directory of host volumes with relative mount points,
            then the srcdir is the basedir, otherwise it is the dir of infile.

" >&2
}

_GETOPTS()
{
    local _SPACE_NAME="_GETOPTS"

    local simpleSwitches="${1}"
    shift

    local richSwitches="${1}"
    shift

    local minPositional="${1:-0}"
    shift

    local maxPositional="${1:-0}"
    shift

    _out_rest=""

    local options=""
    local option=
    for option in ${richSwitches}; do
        options="${options}${option}:"
    done

    local posCount="0"
    while [ "$#" -gt 0 ]; do
        local flag="${1#-}"
        if [ "${flag}" = "${1}" ]; then
            # Non switch
            posCount="$((posCount+1))"
            if [ "${posCount}" -gt "${maxPositional}" ]; then
                PRINT "Too many positional arguments, max ${maxPositional}" "error" 0
                return 1
            fi
            _out_rest="${_out_rest}${_out_rest:+ }${1}"
            shift
            continue
        fi
        local flag2=
        STRING_SUBSTR "${flag}" 0 1 "flag2"
        if STRING_ITEM_INDEXOF "${simpleSwitches}" "${flag2}"; then
            if [ "${#flag}" -gt 1 ]; then
                PRINT "Invalid option: -${flag}" "error" 0
                return 1
            fi
            eval "_out_${flag}=\"true\""
            shift
            continue
        fi

        local OPTIND=1
        getopts ":${options}" "flag"
        case "${flag}" in
            \?)
                PRINT "Unknown option ${1-}" "error" 0
                return 1
                ;;
            :)
                PRINT "Option -${OPTARG-} requires an argument" "error" 0
                return 1
                ;;
            *)
                STRING_ESCAPE "OPTARG"
                eval "_out_${flag}=\"${OPTARG}\""
                ;;
        esac
        shift $((OPTIND-1))
    done

    if [ "${posCount}" -lt "${minPositional}" ]; then
        PRINT "Too few positional arguments, min ${minPositional}" "error" 0
        return 1
    fi
}

COMPILE_ENTRY()
{
    local _SPACE_NAME="COMPILE_ENTRY"

    local podName="${1:-}"
    shift $(($# > 0 ? 1 : 0))

    local inFile="${1:-}"
    shift $(($# > 0 ? 1 : 0))

    local outFile="${1:-}"
    shift $(($# > 0 ? 1 : 0))

    local srcDir="${1:-}"
    shift $(($# > 0 ? 1 : 0))

    local doPreprocessing="${1:-true}"
    shift $(($# > 0 ? 1 : 0))

    if [ -z "${podName}" ]; then
        podName="${PWD##*/}"
        #podName="$(printf "%s\\n" "${podName}" |tr '[:upper:]' '[:lower:]')"
        PRINT "No pod name given as first argument, assuming: ${podName}" "info" 0
    fi

    if [ -z "${inFile}" ]; then
        inFile="pod.yaml"
        PRINT "No in file given as second argument, assuming: ${inFile}" "info" 0
    fi

    inFile="$(FILE_REALPATH "${inFile}")"

    if [ ! -f "${inFile}" ]; then
        PRINT "Yaml file does not exist." "error" 0
        printf "Usage: pod [podname] [-f infile] [-o outfile] [-d srcdir] [-p true|false]\\n" >&2
        return 1
    fi

    if [ -z "${outFile}" ]; then
        outFile="${inFile%.yaml}"
    fi
    if [ "${inFile}" = "${outFile}" ]; then
        outFile="${inFile}.out"
    fi
    local buildDir="${inFile%/*}"

    local filename="${inFile##*/}"
    local yamlfile=
    if [ "${doPreprocessing}" = "true" ]; then
        yamlfile="${buildDir}/.${filename}"
        local text="$(cat "${inFile}")"
        local variablestosubst="$(TEXT_EXTRACT_VARIABLES "${text}")"
        # Load .env env file, if any
        local envfile="${inFile%.yaml}.env"
        # Preinject the podVersion as a value loaded from .env file
        local podVersion="$(grep -m1 "^podVersion:" "${inFile}" | awk -F: '{print $2}' | tr -d " \"'")"
        local values="podVersion=${podVersion}"
        local newline="
"
        if [ -f "${envfile}" ]; then
            PRINT "Loading variables from .env file." "info" 0
            values="${values}${newline}$(cat "${envfile}")"
        else
            PRINT "No .env file present." "info" 0
        fi
        # Fill in missing variables from environment
        local varname=
        local varnames=""
        for varname in ${variablestosubst}; do
            if ! printf "%s\\n" "${values}" |grep -q "^${varname}="; then
                varnames="${varnames}${varnames:+ }${varname}"
            fi
        done
        if [ -n "${varnames}" ]; then
            PRINT "Sourcing variables from environment since they are not defined in .env file, for variables: ${varnames}" "info" 0
            if ! values="${values}${values:+${newline}}$(TEXT_GET_ENV "${varnames}" "1")"; then
                PRINT "There are missing variables in .env file or environment." "warning" 0
            fi
        fi

        text="$(TEXT_VARIABLE_SUBST "${text}" "${variablestosubst}" "${values}")"

        # Parse contents
        printf "%s\\n" "${text}" |TEXT_FILTER >"${yamlfile}"
    else
        yamlfile="${inFile}"
    fi

    if ! _COMPILE_POD "${podName}" "${yamlfile}" "${outFile}" "${srcDir}"; then
        return 1
    fi
}

VERSION()
{
    local _SPACE_NAME="VERSION"
    printf "%s\\n" "Simplenetes pod compiler version 0.1 for api: 1.0.0-beta1"
}

PRINT()
{
    local color=''
    local header=''
    [ "${3:-1}" = 1 ] && {
        local _SPACE_NAME="${_SPACE_NAME:-anonymous}: ";
    } || {
        local _SPACE_NAME="";
    }

    case "${2:-info}" in
        error)
            if [ "${SPACE_LOG_LEVEL:-4}" -lt 1 ]; then return; fi
            header="[ERROR] "; color="\033[31m"
            ;;
        security)
            if [ "${SPACE_LOG_LEVEL:-4}" -lt 1 ]; then return; fi
            header="[SEC]   "; color="\033[35m"
            ;;
        warning)
            if [ "${SPACE_LOG_LEVEL:-4}" -lt 2 ]; then return; fi
            header="[WARN]  "; color="\033[33m"
            ;;
        ok)
            if [ "${SPACE_LOG_LEVEL:-4}" -lt 3 ]; then return; fi
            header="[OK]    "; color="\033[32m"
            ;;
        info)
            if [ "${SPACE_LOG_LEVEL:-4}" -lt 4 ]; then return; fi
            header="[INFO]  "; color="\033[37m"
            ;;
        debug)
            if [ "${SPACE_LOG_LEVEL:-4}" -lt 5 ]; then return; fi
            header="[DEBUG] "; color=""
            ;;
        *)
            return
            ;;
    esac
    if [ "${SPACE_LOG_ENABLE_COLORS}" = "1" ] && [ -t 2 ]; then
        printf "${color}%s%s%s\033[0m\n" "${header}" "${_SPACE_NAME}" "${1}" >&2
    else
        printf "%s%s%s\n" "${header}" "${_SPACE_NAME}" "${1}" >&2
    fi
}

STRING_SUBSTR()
{
    local _SPACE_NAME="STRING_SUBSTR"

    # shellcheck disable=SC2034
    local __sopriv="${1}"
    shift

    local __index="${1}"
    shift

    local __length="${1}"
    shift

    local __outvar="${1:-}"
    shift $(( $# > 0 ? 1 : 0 ))

    local __strlength="${#__sopriv}"

    if [ "${__index}" -lt 0 ]; then
        __index=$((__strlength+__index))
    fi

    if [ "${__index}" -ge 0 ]; then
        if [ "${__length}" = "" ]; then
            __length=$((__strlength-__index))
        fi

        if [ "${__length}" -lt 0 ]; then
            __length=$((__strlength-__index+__length))
        fi

        if [ "$((__index+__length))" -le "${#__sopriv}" ]; then
            local __wildcard=
            STRING_REPEAT "?" "${__index}" "" "__wildcard"
            local __substr="${__sopriv#${__wildcard}}"
            STRING_REPEAT "?" "$((${#__substr}-__length))" "" "__wildcard"
            __substr="${__substr%${__wildcard}}"
            if [ -n "${__outvar}" ]; then
                eval "${__outvar}=\"\${__substr}\""
            else
                printf "%s\\n" "${__outvar}"
            fi
            return 0
        fi

    fi

    if [ -n "${__outvar}" ]; then
        eval "${__outvar}=\"\""
    fi
}

STRING_INDEXOF()
{
    local _SPACE_NAME="STRING_INDEXOF"

    local substr="${1}"
    shift

    local string="${1}"
    shift

    local varname="${1-}"
    shift $(( $# > 0 ? 1 : 0 ))

    local rest="${string%%${substr}*}"

    if [ "${rest}" = "${string}" ]; then
        if [ -n "${varname}" ]; then
            eval "${varname}=\"-1\""
        fi
        return 1
    fi

    if [ -n "${varname}" ]; then
        eval "${varname}=\"${#rest}\""
    fi
    return 0
}

STRING_ESCAPE()
{
    local _SPACE_NAME="STRING_ESCAPE"

    local ___char=
    for ___char in \" \$ \( \) \< \> \| \& \/; do
        case "${2-\"\$}" in
            *${___char}*)
                _STRING_ESCAPE "${1}" "${___char}"
                ;;
        esac
    done
}

_COMPILE_POD()
{
    local _SPACE_NAME="_COMPILE_POD"

    local podName="${1}"
    shift

    if [[ ! $podName =~ ^[a-z]([_a-z0-9]*[a-z0-9])?$ ]]; then
        PRINT "Podname '${podName}' is malformed. only lowercase letters [a-z], numbers [0-9] and underscore is allowed. First character must be lowercase letter" "error" 0
        return 1
    fi

    local inFile="${1}"
    shift

    local outFile="${1}"
    shift

    if [ -d "${outFile}" ]; then
        PRINT "${outFile} is a directory" "error" 0
        return 1
    fi

    local srcDir="${1}"
    shift $(($# > 0 ? 1 : 0))

    if [ ! -f "${inFile}" ]; then
        PRINT "Yaml file does not exist." "error" 0
        return 1
    fi

    if [ -z "${srcDir}" ]; then
        srcDir="${inFile%/*}"
    fi

    # Output the fill YAML file if in debug mode
    local dbgoutput="$(cat "${inFile}")"
    PRINT "Pod YAML: "$'\n'"${dbgoutput}" "debug" 0

    # Load and parse YAML
    # Bashism
    local evals=()
    YAML_PARSE "${inFile}" "evals"
    eval "${evals[@]}"

    # get api version
    local api=
    _copy "api" "/api"

    if [ "${api}" != "1.0.0-beta1" ]; then
        PRINT "api must be set to '1.0.0-beta1'" "error" 0
        return 1
    fi

    # get runtime
    local runtime=
    _copy "runtime" "/runtime"
    if [ -z "${runtime}" ]; then
        runtime="podman"
    fi

    # get podVersion
    local podVersion=
    _copy "podVersion" "/podVersion"
    if [[ ! $podVersion =~ ^([0-9]+\.[0-9]+\.[0-9]+(-[-a-z0-9\.]*)?)$ ]]; then
        PRINT "podVersion is missing/invalid. Must be on semver format (major.minor.patch[-tag])." "error" 0
        return 1
    fi

    local runtimeDir=""
    local runtimeDir="${0%/*}"
    if [ "${runtimeDir}" = "${0}" ]; then
        # This is weird, not slash in path, but we will handle it.
        if [ -f "./${0}" ]; then
            # This happens when the script is invoked as `bash pod.sh`.
            runtimeDir="${PWD}"
        else
            PRINT "Could not determine the base dir podc." "error" 0
            return 1
        fi
    fi
    runtimeDir="$(FILE_REALPATH "${runtimeDir}")"

    PRINT "Compiling \"${podName}-${podVersion}\" for api version: \"${api}\" and runtime \"${runtime}\", YAML file: ${inFile}." "info" 0

    if [ "${runtime}" = "podman" ]; then
        # Get path to runtime
        local runtimePath=""
        while true; do
            for runtimePath in "${runtimeDir}/podman-runtime-${api}" "${runtimeDir}/lib/podman-runtime-${api}" "${runtimeDir}/release/podman-runtime-${api}" "/opt/podc/podman-runtime-${api}"; do
                if [ -f "${runtimePath}" ]; then
                    break 2
                fi
            done
            PRINT "Could not locate podman-runtime-${api}" "error" 0
            return 1
        done
        local buildDir="${outFile%/*}"
        local POD_PROXYCONF=""
        local POD_INGRESSCONF=""
        local _out_pod=""
        if ! _COMPILE_PODMAN "${podName}" "${podVersion}" "${runtimePath}" "${buildDir}"; then
            PRINT "Could not compile pod for podman runtime." "error" 0
            return 1
        fi
        PRINT "Writing pod executable to ${outFile}" "ok" 0
        printf "%s\\n" "${_out_pod}" >"${outFile}"
        chmod +x "${outFile}"
        local portmappingsFile="${outFile}.portmappings.conf"
        # Make into dotfile
        portmappingsFile="${portmappingsFile%/*}/.${portmappingsFile##*/}"

        local ingressFile="${outFile}.ingress.conf"
        # Make into dotfile
        ingressFile="${ingressFile%/*}/.${ingressFile##*/}"

        if [ -n "${POD_PROXYCONF}" ]; then
            printf "%s\\n" "${POD_PROXYCONF}" >"${portmappingsFile}"
        else
            rm -f "${portmappingsFile}"
        fi
        if [ -n "${POD_INGRESSCONF}" ]; then
            printf "%s\\n" "${POD_INGRESSCONF}" >"${ingressFile}"
        else
            rm -f "${ingressFile}"
        fi
    elif [ "${runtime}" = "executable" ]; then
        if ! _COMPILE_EXECUTABLE "${podName}" "${podVersion}" "${srcDir}" "${outFile}"; then
            PRINT "Could not compile pod for executable runtime." "error" 0
            return 1
        fi
        PRINT "Writing pod executable to ${outFile}" "ok" 0
    else
        PRINT "Unknown runtime \"${runtime}\" . Only \"podman\" or \"executable\" runtimes are supported." "error" 0
        return 1
    fi
}

TEXT_EXTRACT_VARIABLES()
{
    local _SPACE_NAME="TEXT_EXTRACT_VARIABLES"

    local text="${1}"
    shift

    printf "%s\\n" "${text}" |
        awk '
            {
                while (match($0,/(\$\{[A-Za-z_][0-9A-Za-z_]*\})/))
                {
                    result = substr($0,RSTART+2,RLENGTH-3);
                    print result;
                    $0 = substr($0,RSTART+RLENGTH);
                }
            }' |
        sort |uniq
}

TEXT_VARIABLE_SUBST()
{
    local _SPACE_NAME="TEXT_VARIABLE_SUBST"

    local text="${1}"
    shift

    local variables="${1}"
    shift

    local values="${1}"
    shift

    local value=
    local varname=
    for varname in ${variables}; do
        value="$(printf "%s\\n" "${values}" |grep -m 1 "^${varname}=")"
        value="${value#${varname}=}"
        varname="\${${varname}}"
        STRING_ESCAPE "varname" '/'
        STRING_ESCAPE "value" '/'
        text="$(printf "%s\\n" "${text}" |sed "s/${varname}/${value}/g")"
    done

    printf "%s\\n" "${text}"
}

TEXT_FILTER()
{
    local _SPACE_NAME="TEXT_FILTER"
    local awkscript='
    BEGIN {
        count=0
        keep=1
    }

    {
        if (match($0,/^#endif[ ]*$/))
        {
            count--;
            if (count == 0)
            {
                keep=1
                next
            }
        }
    }

    {
        if (match($0,/^#if([n]?)def[ ]?([^ ]*)$/))
        {
            count++;
            if (count == 1)
            {
                if (length(substr($2,RSTART,RLENGTH)) >0)
                {
                    if (substr($1,RSTART,RLENGTH)=="#ifdef")
                    {
                        keep=1
                    }
                    else if (substr($1,RSTART,RLENGTH)=="#ifndef")
                    {
                        keep=0
                    }
                }
                else
                {
                    if (substr($1,RSTART,RLENGTH)=="#ifdef")
                    {
                        keep=0
                    }
                    else if (substr($1,RSTART,RLENGTH)=="#ifndef")
                    {
                        keep=1
                    }
                }
                next
            }
        }
    }

    {
        if (match($0,/^#if([n]?)true[ ]?([^ ]*)$/))
        {
            count++;
            if (count == 1)
            {
                if (substr($2,RSTART,RLENGTH)=="true")
                {
                    keep=1
                }
                else
                {
                    keep=0
                }
                if (substr($1,RSTART,RLENGTH)=="#iftrue")
                {
                    keep=keep
                }
                else if (substr($1,RSTART,RLENGTH)=="#ifntrue")
                {
                    keep=!keep
                }

                next
            }
        }
    }

    {
        if (keep)
        {
            print
        }
    }

    END {
        if (count >0)
        {
            print "Error: Missing #endif" > "/dev/stderr"
        }
    }
'
    local text="$(cat)"
    local text2="${text}"
    while true; do
        text2="$(printf "%s\\n" "${text}" |awk "${awkscript}")"
        if [ "${text2}" = "${text}" ]; then
            break
        fi
        text="${text2}"
    done
    printf "%s\\n" "${text}"
}

TEXT_GET_ENV()
{
    local _SPACE_NAME="TEXT_GET_ENV"

    local variables="${1}"
    shift

    local failonerror="${1:-1}"
    shift

    local varname=
    local value=
    for varname in ${variables}; do
        if ! env |grep "^${varname}="; then
            if [ "${failonerror}" = "1" ]; then
                return 1
            fi
        fi
    done
}

FILE_REALPATH()
{
    local _SPACE_NAME="FILE_REALPATH"

    local file="${1}"
    shift

    local pwd="${1:-$PWD}"

    if [ "${file#/}" != "${file}" ]; then
        # Already absolute
        # Fall through for cleaning swipe
        :
    else
        # Prepend the current directory.
        file="${pwd}/${file}"
    fi

    # Remove dots and act on double dots.
    local count=
    local item=
    while true; do
        local _ifs="${IFS}"
        local IFS="/"
        STRING_ITEM_COUNT "${file}" "count"
        IFS=${_ifs}
        local index=-1
        local keepIndexes=""
        while [ "${index}" -lt "$((count-1))" ]; do
            index="$((index+1))"
            local _ifs="${IFS}"
            IFS="/"
            STRING_ITEM_GET "${file}" "${index}" "item"
            IFS=${_ifs}
            if [ -z "${item}" ]; then
                # Discard it
                continue
            elif [ "${item}" = "." ]; then
                # Discard it
                continue
            elif [ "${item}" = ".." ]; then
                # Discard this one, and also the previous one
                # Cut away last keep index
                keepIndexes="${keepIndexes%[ ]*}"
                continue
            fi
            # Keep this one. The space here is important in all cases due to how it is cut above.
            keepIndexes="${keepIndexes} ${index}"
        done
        # Put together the file again
        local file2=
        for index in ${keepIndexes}; do
            local _ifs="${IFS}"
            IFS="/"
            STRING_ITEM_GET "${file}" "${index}" "item"
            IFS=${_ifs}
            file2="${file2}/${item}"
        done
        if [ "${file}" = "${file2}" ]; then
            # We are done
            file="${file2}"
            break
        fi
        file="${file2}"
    done
    file="${file:-/}"

    printf "%s\\n" "${file}"
}

STRING_REPEAT()
{
    local _SPACE_NAME="STRING_REPEAT"

    local __string="${1}"
    shift

    local __count="${1}"
    shift

    local __separator="${1}"
    shift

    local __outvar="${1}"
    shift

    local __repeatedstring=""
    while [ "${__count}" -gt 0 ]; do
        __count=$((__count-1))
        __repeatedstring="${__repeatedstring}${__string}"
        if [ "${__count}" -gt 0 ]; then
            __repeatedstring="${__repeatedstring}${__separator}"
        fi
    done

    eval "${__outvar}=\"\${__repeatedstring}\""
}

_STRING_ESCAPE()
{
    local _SPACE_NAME="_STRING_ESCAPE"
    local __right=
    local __result=""
    eval "__right=\$${1}"
    local __left=
    while true; do
        # Cut from right up until last occurrence of char.
        __left="${__right%%${2}*}"
        if [ "${__left}" = "${__right}" ]; then
            # Done
            __result="${__result}${__left}"
            break
        fi
        __right="${__right#$__left}"
        # This seems to be necessary the remove the escapes properly.
        __right="${__right#*${2}}"
        # Now cut away from right all escapes, one by one..
        local __escapes=""
        local __left2=
        while true; do
            __left2="${__left%[\\]}"
            if [ "${__left2}" = "${__left}" ]; then
                # No more escapes
                break
            fi
            # Escape encountered
            __escapes="${__escapes}\\"
            __left="${__left2}"
        done
        # Double the number of escapes and add one.
        __result="${__result}${__left}${__escapes}${__escapes}\\${2}"
    done
    eval "${1}=\${__result}"
}

YAML_PARSE()
{
    local _SPACE_NAME="YAML_PARSE"

    YAML_PARSE_IMPL "$@"
}

_CONTAINER_VARS()
{
    local _SPACE_NAME="_CONTAINER_VARS"

    local container_nr="${1}"
    shift

    printf "%s\\n" "
local POD_CONTAINER_NAME_${container_nr}=
local POD_CONTAINER_STARTUPPROBE_${container_nr}=
local POD_CONTAINER_STARTUPTIMEOUT_${container_nr}=
local POD_CONTAINER_STARTUPSIGNAL_${container_nr}=
local POD_CONTAINER_READINESSPROBE_${container_nr}=
local POD_CONTAINER_READINESSTIMEOUT_${container_nr}=
local POD_CONTAINER_LIVENESSPROBE_${container_nr}=
local POD_CONTAINER_LIVENESSTIMEOUT_${container_nr}=
local POD_CONTAINER_SIGNALSIG_${container_nr}=
local POD_CONTAINER_SIGNALCMD_${container_nr}=
local POD_CONTAINER_RESTARTPOLICY_${container_nr}=
local POD_CONTAINER_CONFIGS_${container_nr}=
local POD_CONTAINER_MOUNTS_${container_nr}=
local POD_CONTAINER_ENV_${container_nr}=
local POD_CONTAINER_COMMAND_${container_nr}=
local POD_CONTAINER_ARGS_${container_nr}=
local POD_CONTAINER_WORKINGDIR_${container_nr}=
local POD_CONTAINER_CPUMEM_${container_nr}=
local POD_CONTAINER_PORTS_${container_nr}=
local POD_CONTAINER_RUN_${container_nr}="
}

_CONTAINER_SET_VAR()
{
    local _SPACE_NAME="_CONTAINER_SET_VAR"

    local container_nr="${1}"
    shift

    local varname="${1}"
    shift

    local valuevarname="${1}"
    shift

    local quote="${1:-0}"
    shift

    if [ "${quote}" = "1" ]; then
        STRING_ESCAPE "${valuevarname}" '"'
    fi

    eval "POD_CONTAINER_${varname}_${container_nr}=\"\${${valuevarname}}\""
}

_QUOTE_ARG()
{
    local _SPACE_NAME="_QUOTE_ARG"

    local argname="${1}"
    shift

    # Dereference the variable, bashism
    local argvalue="${!argname}"

    local firstchar=
    local lastchar=
    STRING_SUBSTR "${argvalue}" 0 1 "firstchar"
    STRING_SUBSTR "${argvalue}" -1 1 "lastchar"

    local addquotes=0
    if [ "${firstchar}" = "${argvalue}" ]; then
        # Empty string or single char
        addquotes=1
    elif [ "${firstchar}" = "${lastchar}" ] && [ "${firstchar}" = "\"" ]; then
        # Properly formatted string, do nothing
        :
    elif [ "${firstchar}" = "${lastchar}" ] && [ "${firstchar}" = "'" ]; then
        # String enclosed in single quotes,
        # remove single quotes
        STRING_SUBSTR "${argvalue}" 1 -1 "${argname}"
        addquotes=1
    else
        # Whatever this is, add quotes
        addquotes=1
    fi

    # Check if we need to enclose the argument in quotes
    if [ "${addquotes}" = "1" ]; then
        STRING_ESCAPE "${argname}"
        eval "${argname}=\"\\\"\${${argname}}\\\"\""
    fi

    # Now lift the whole argument.
    STRING_ESCAPE "${argname}"
}

STRING_ITEM_INDEXOF()
{
    local _SPACE_NAME="STRING_ITEM_INDEXOF"

    local __s="${1}"
    shift

    local __item="${1}"
    shift

    local __outvar="${1-}"
    shift $(( $# > 0 ? 1 : 0 ))

    local __item2=
    local __count=0
    for __item2 in ${__s}; do
        if [ "${__item}" = "${__item2}" ]; then
            if [ -n "${__outvar}" ]; then
                eval "${__outvar}=\"\${__count}\""
            fi
            return 0
        fi
        __count=$((__count+1))
    done
    if [ -n "${__outvar}" ]; then
        eval "${__outvar}=\"-1\""
    fi
    return 1
}

STRING_ITEM_GET()
{
    local _SPACE_NAME="STRING_ITEM_GET"

    local __s="${1}"
    shift

    local __index="${1}"
    shift

    local __outvar="${1}"
    shift

    local __item=
    local __count=0
    for __item in ${__s}; do
        if [ "${__count}" -eq "${__index}" ]; then
            eval "${__outvar}=\"\${__item}\""
            break
        fi
        __count=$((__count+1))
    done
}

_GET_CONTAINER_NR()
{
    local _SPACE_NAME="_GET_CONTAINER_NR"

    local containername="${1}"
    shift

    local index=
    local name=
    for index in $(seq 1 ${POD_CONTAINER_COUNT}); do
        _GET_CONTAINER_VAR "${index}" "NAME" "name"
        if [ "${containername}" = "${name}" ]; then
            printf "%s\\n" "${index}"
            return 0
        fi
    done
    return 1
}

_COMPILE_INGRESS()
{
    local _SPACE_NAME="_COMPILE_INGRESS"

    local prefix="${1}"
    shift

    local useTargetPorts="${1:-true}"
    shift $(($# > 0 ? 1 : 0))

    # Internal "macro" function. We don't define any SPACE_ headers for this.

    local portmappings=""
    local lines=()

    local exposeindex=()
    _list "exposeindex" "${prefix}"
    local index0=
    for index0 in "${exposeindex[@]}"; do
        # Get targetPort, clusterPort, hostPort
        local targetPort=
        _copy "targetPort" "${prefix}${index0}/targetPort"
        STRING_SUBST "targetPort" "'" "" 1
        STRING_SUBST "targetPort" '"' "" 1
        local clusterPort=
        _copy "clusterPort" "${prefix}${index0}/clusterPort"
        STRING_SUBST "clusterPort" "'" "" 1
        STRING_SUBST "clusterPort" '"' "" 1
        local hostPort=
        _copy "hostPort" "${prefix}${index0}/hostPort"
        STRING_SUBST "hostPort" "'" "" 1
        STRING_SUBST "hostPort" '"' "" 1
        local sendproxy=
        _copy "sendproxy" "${prefix}${index0}/sendProxy"
        STRING_SUBST "sendproxy" "'" "" 1
        STRING_SUBST "sendproxy" '"' "" 1
        local maxconn=
        _copy "maxconn" "${prefix}${index0}/maxConn"
        STRING_SUBST "maxconn" "'" "" 1
        STRING_SUBST "maxconn" '"' "" 1

        if [ -n "${maxconn}" ]; then
            if [[ ! $maxconn =~ ^([0-9])+$ ]]; then
                PRINT "maxconn must be an integer." "error" 0
                return 1
            fi
        else
            maxconn=4096  # Default value
        fi
        if [ -n "${sendproxy}" ]; then
            if [ "${sendproxy}" = "true" ] || [ "${sendproxy}" = "false" ]; then
                :
            else
                PRINT "Illegal value for sendProxy. Must be set to true or false, default is false." "error" 0
                return 1
            fi
        else
            sendproxy="false"
        fi

        if [ "${useTargetPorts}" = "false" ]; then
            if [ -n "${targetPort}" ]; then
                PRINT "targetPort not allowed for this pod runtime." "error" 0
                return 1
            fi
            targetPort="0"
        fi

        if [ -n "${hostPort}" ]; then
            if [[ ! $hostPort =~ ^([0-9])+$ ]]; then
                PRINT "hostPort must be an integer." "error" 0
                return 1
            fi

            if [ "${hostPort}" -lt "1" ] || [ "${hostPort}" -gt "65535" ]; then
                PRINT "Host port must be between 1 and 65535 (but typically not between 61000-63999 and 32767)." "error" 0
                return 1
            fi

            if [ "${useTargetPorts}" = "true" ]; then
                if [[ ! $targetPort =~ ^([0-9])+$ ]]; then
                    PRINT "targetPort must be an integer." "error" 0
                    return 1
                fi

                if [ "${targetPort}" -lt "1" ] || [ "${targetPort}" -gt "65535" ]; then
                    PRINT "Target port must be between 1 and 65535." "error" 0
                    return 1
                fi
            fi

            if [ -n "${clusterPort}" ]; then
                if [[ ! $clusterPort =~ ^([0-9])+$ ]]; then
                    PRINT "clusterPort must be an integer." "error" 0
                    return 1
                fi

                if [ "${clusterPort}" -lt "1024" ] || [ "${clusterPort}" -gt "65535" ]; then
                    PRINT "Cluster port must be between 1024 and 65535, but not between 30000-32767." "error" 0
                    return 1
                fi

                if [ "${clusterPort}" -ge "30000" ] && [ "${clusterPort}" -le "32767" ]; then
                    PRINT "Cluster port cannot be in the reserved range of 30000-32767." "error" 0
                    return 1
                fi
            else
                clusterPort="0"
            fi

            portmappings="${portmappings} ${clusterPort}:${hostPort}:${targetPort}:${maxconn}:${sendproxy}"

            if STRING_ITEM_INDEXOF "${POD_HOSTPORTS}" "${hostPort}"; then
                PRINT "A hostPort can only be defined once in ingress, for hostPort ${hostPort} and targetPort ${targetPort}." "error" 0
                return 1
            fi
            POD_HOSTPORTS="${POD_HOSTPORTS}${POD_HOSTPORTS:+ }${hostPort}"
        else
            clusterPort="0"
        fi

        local prefix2="${prefix}${index0}/ingress/"
        local ingressindex=()
        _list "ingressindex" "${prefix2}"
        local index1=
        for index1 in "${ingressindex[@]}"; do
            local domain=
            local bind=
            local protocol=
            local weight=
            local path_beg=
            local path_end=
            local path=
            local redirect_to_https=
            local redirect_location=
            local redirect_prefix=
            local errorfile=
            _copy "protocol" "${prefix2}${index1}/protocol"
            STRING_SUBST "protocol" "'" "" 1
            STRING_SUBST "protocol" '"' "" 1
            _copy "bind" "${prefix2}${index1}/bind"
            STRING_SUBST "bind" "'" "" 1
            STRING_SUBST "bind" '"' "" 1
            _copy "domain" "${prefix2}${index1}/domain"
            STRING_SUBST "domain" "'" "" 1
            STRING_SUBST "domain" '"' "" 1
            _copy "weight" "${prefix2}${index1}/weight"
            STRING_SUBST "weight" "'" "" 1
            STRING_SUBST "weight" '"' "" 1
            _copy "path_beg" "${prefix2}${index1}/pathBeg"
            STRING_SUBST "path_beg" "'" "" 1
            STRING_SUBST "path_beg" '"' "" 1
            _copy "path_end" "${prefix2}${index1}/pathEnd"
            STRING_SUBST "path_end" "'" "" 1
            STRING_SUBST "path_end" '"' "" 1
            _copy "path" "${prefix2}${index1}/path"
            STRING_SUBST "path" "'" "" 1
            STRING_SUBST "path" '"' "" 1
            _copy "redirect_to_https" "${prefix2}${index1}/redirectToHttps"
            STRING_SUBST "redirect_to_https" "'" "" 1
            STRING_SUBST "redirect_to_https" '"' "" 1
            _copy "redirect_location" "${prefix2}${index1}/redirectLocation"
            STRING_SUBST "redirect_location" "'" "" 1
            STRING_SUBST "redirect_location" '"' "" 1
            _copy "redirect_prefix" "${prefix2}${index1}/redirectPrefix"
            STRING_SUBST "redirect_prefix" "'" "" 1
            STRING_SUBST "redirect_prefix" '"' "" 1
            _copy "errorfile" "${prefix2}${index1}/errorfile"
            STRING_SUBST "errorfile" "'" "" 1
            STRING_SUBST "errorfile" '"' "" 1

            if ! STRING_ITEM_INDEXOF "http https tcp" "${protocol}"; then
                PRINT "Unknown protocol ${protocol} in ingress. Only: http, https and tcp allowed" "error" 0
                return 1
            fi

            if [ -z "${bind}" ]; then
                if [ "${protocol}" = "http" ]; then
                    bind="80"
                elif [ "${protocol}" = "https" ]; then
                    bind="443"
                elif [ "${protocol}" = "tcp" ]; then
                    PRINT "For tcp protocol a bind port must be provided." "error" 0
                    return 1
                fi
            else
                # Check so bind is valid
                if [[ ! $bind =~ ^([0-9])+$ ]]; then
                    PRINT "Bind must be an integer." "error" 0
                    return 1
                fi
            fi

            if [ -z "${weight}" ]; then
                weight="100"
            else
                if [[ ! $weight =~ ^([0-9])+$ ]]; then
                    PRINT "Importance must be an integer." "error" 0
                    return 1
                fi
            fi

            lines+=("bind ${bind}")
            lines+=("protocol ${protocol}")
            lines+=("host ${domain}")
            lines+=("weight ${weight}")

            local httpSpecific=0
            if [ -n "${path}" ]; then
                lines+=("path ${path}")
                httpSpecific=1
            fi

            if [ -n "${path_beg}" ]; then
                lines+=("path_beg ${path_beg}")
                httpSpecific=1
            fi

            if [ -n "${path_end}" ]; then
                lines+=("path_end ${path_end}")
                httpSpecific=1
            fi

            if [ "${redirect_to_https}" = "true" ]; then
                lines+=("redirect_to_https true")
                httpSpecific=1
            elif [ -n "${redirect_location}" ]; then
                lines+=("redirect_location ${redirect_location}")
                httpSpecific=1
            elif [ -n "${redirect_prefix}" ]; then
                lines+=("redirect_prefix ${redirect_prefix}")
                httpSpecific=1
            elif [ -n "${errorfile}" ]; then
                lines+=("errorfile ${errorfile}")
                httpSpecific=1
            else
                # server backend.
                # This requires that any http psecific criteria has been set, of http/s
                if [ "${httpSpecific}" = "0" ] && { [ "${protocol}" = "http" ] || [ "${protocol}" = "https" ]; }; then
                    PRINT "Missing http/s specific criterion. Ex: path, pathBeg, pathEnd, etc" "error" 0
                    return 1
                fi


                # This requires a hostPort
                if [ -z "${hostPort}" ]; then
                    PRINT "This pod yaml ingress is lacking a hostPort definition." "error" 0
                    return 1
                fi
                # This requires a clusterPort >0
                if [ "${clusterPort}" -eq 0 ]; then
                    PRINT "This pod yaml ingress is lacking a clusterPort definition." "error" 0
                    return 1
                fi
                lines+=("clusterport ${clusterPort}")
            fi

            if [ "${httpSpecific}" = "1" ] && [ "${protocol}" = "tcp" ]; then
                PRINT "Cannot have HTTP specific matching and actions for TCP protocol. Such as path, pathBeg, redirect, etc." "error" 0
                return 1
            fi

        done
    done

    if [ -n "${POD_INGRESSCONF}" ]; then
        local nl="
"
        POD_INGRESSCONF="${POD_INGRESSCONF}${nl}$(printf "%s\\n" "${lines[@]}")"
    else
        POD_INGRESSCONF="$(printf "%s\\n" "${lines[@]}")"
    fi

    # Create the port mapping for the container.
    local arg=
    for arg in ${portmappings}; do
        local clusterPort="${arg%%:*}"
        local hostPort="${arg%:*:*:*}"
        hostPort="${hostPort#*:}"
        local targetPort="${arg%:*:*}"
        targetPort="${targetPort#*:*:}"
        local maxConn="${arg%:*}"
        maxConn="${maxConn#*:*:*:}"
        local sendProxy="${arg##*:}"
        if [ "${clusterPort}" -gt 0 ]; then
            # Only expose in cluster if clusterPort >0
            local nl="
"
            POD_PROXYCONF="${POD_PROXYCONF}${POD_PROXYCONF:+$nl}${clusterPort}:${hostPort}:${maxConn}:${sendProxy}"
        fi
        _out_container_ports="${_out_container_ports}${_out_container_ports:+ }-p ${hostPort}:${targetPort}"
    done
}

_COMPILE_RUN()
{
    local _SPACE_NAME="_COMPILE_RUN"
    local run="\\\${ADD_PROXY_IP:-} --name \${POD_CONTAINER_NAME_${POD_CONTAINER_COUNT}} \${POD_CONTAINER_ENV_${POD_CONTAINER_COUNT}} \${POD_CONTAINER_PORTS_${POD_CONTAINER_COUNT}} \${POD_CONTAINER_COMMAND_${POD_CONTAINER_COUNT}} \${POD_CONTAINER_MOUNTS_${POD_CONTAINER_COUNT}} \${POD_CONTAINER_WORKINGDIR_${POD_CONTAINER_COUNT}} \${POD_CONTAINER_IMAGE_${POD_CONTAINER_COUNT}} \${POD_CONTAINER_ARGS_${POD_CONTAINER_COUNT}}"
    _CONTAINER_SET_VAR "${POD_CONTAINER_COUNT}" "RUN" "run"
}

_COMPILE_LABELS()
{
    local _SPACE_NAME="_COMPILE_LABELS"

    local extraLabels="${1:-}"

    local labels=""
    local index=()
    _list "index" "/labels/"
    local index0=
    # TODO: validate keys and values, as: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set
    for index0 in "${index[@]}"; do
        local name=
        _copy "name" "/labels/${index0}/name"
        STRING_SUBST "name" "'" "" 1
        STRING_SUBST "name" '"' "" 1
        local value=
        _copy "value" "/labels/${index0}/value"
        STRING_SUBST "value" "'" "" 1
        STRING_SUBST "value" '"' "" 1
        if ! STRING_IS_ALL "${value}" "A-Za-z0-9_./-"; then
            PRINT "Invalid characters in labels. Only [A-Za-z0-9._-/] allowed" "error" 0
            return 1
        fi
        labels="${labels}${labels:+ }--label ${name}=${value}"
    done

    POD_LABELS="${labels}${labels:+ }${extraLabels}"
}

_COMPILE_ENTRYPOINT()
{
    local _SPACE_NAME="_COMPILE_ENTRYPOINT"

    # --entrypoint of container
    # if this is set then the default CMD will get nullified and if wanted has to be
    # provided as "args" parameter in the pod.yaml. As extracted below.
    local subarg=
    local arg=
    local args=
    local value=""
    _list "args" "/containers/${index}/command/" "" 1
    for arg in "${args[@]}"; do
        _copy "subarg" "/containers/${index}/command/${arg}"
        _QUOTE_ARG "subarg"
        value="${value}${value:+, }${subarg}"
    done

    value="${value:+--entrypoint='[$value]'}"
    _CONTAINER_SET_VAR "${POD_CONTAINER_COUNT}" "COMMAND" "value"

    local subarg=
    local arg=
    local args=
    local value=""
    _list "args" "/containers/${index}/args/" "" 1
    for arg in "${args[@]}"; do
        _copy "subarg" "/containers/${index}/args/${arg}"
        _QUOTE_ARG "subarg"
        value="${value}${value:+ }${subarg}"
    done

    _CONTAINER_SET_VAR "${POD_CONTAINER_COUNT}" "ARGS" "value"

    local value=
    _copy "value" "/containers/${index}/workingDir"
    if ! STRING_IS_ALL "${value}" "A-Za-z0-9_./-"; then
        PRINT "Invalid characters in workingDir. Only [A-Za-z0-9._-/] allowed" "error" 0
        return 1
    fi
    value="${value:+--workdir=$value}"
    _CONTAINER_SET_VAR "${POD_CONTAINER_COUNT}" "WORKINGDIR" "value"
}

_COMPILE_CPUMEM()
{
    local _SPACE_NAME="_COMPILE_CPUMEM"
    :
}

STRING_SUBST()
{
    local _SPACE_NAME="STRING_SUBST"

    local __varname="${1}"
    local __rstring=
    eval "__rstring=\"\${$1}\""
    shift

    local __subst="${1}"
    shift

    local __replace="${1}"
    shift

    local __global="${1:-0}"
    shift $(( $# > 0 ? 1 : 0 ))

    local __lstring=
    local __string=""
    while true; do
        __lstring="${__rstring%%${__subst}*}"
        if [ "${__lstring}" = "${__rstring}" ]; then
            __string="${__string}${__rstring}"
            break
        fi
        __string="${__string}${__lstring}${__replace}"
        __rstring="${__rstring#*${__subst}}"
        if [ "${__global}" -ne 1 ]; then
            __string="${__string}${__rstring}"
            break
        fi
    done
    eval "${__varname}=\"\${__string}\""
}

_GET_CONTAINER_VAR()
{
    local _SPACE_NAME="_GET_CONTAINER_VAR"

    local container_nr="${1}"
    shift

    local varname="${1}"
    shift

    local outname="${1}"
    shift

    eval "${outname}=\"\${POD_CONTAINER_${varname}_${container_nr}}\""
}

_COMPILE_PODMAN()
{
    local _SPACE_NAME="_COMPILE_PODMAN"
    local podName="${1}"
    shift

    local podVersion="${1}"
    shift

    local runtimePath="${1}"
    shift

    local buildDir="${1}"
    shift

    local volumesuffix="-${podName}"

    ## Output header of runtime template file
    _out_pod="$(awk 'BEGIN {show=1} /^[^#]/ { show=0 } {if(show==1) {print}}' "${runtimePath}")"

    local POD="${podName}-${podVersion}"
    local POD_VERSION="${podVersion}"  # Part of the pod name.
    local POD_LABELS=""
    local POD_CREATE="--name \${POD}"
    local POD_VOLUMES=""       # Used by runtime to create container volumes.
    local POD_RAMDISKS=""      # Read by the Daemon to create ramdisks.
    local POD_HOSTPORTS=""     # Used by runtime to check that hosts ports are free before starting the pod.
    local POD_CONTAINER_COUNT=0

    local volumes_host=""
    local volumes_config=""
    local volumes_config_encrypted=""
    local volumes_host_bind=""

    # Go over all volumes
    #

    local valid_types="ramdisk config volume host"
    local all_volumes=""
    local volumes=()
    _list "volumes" "/volumes/"
    local index=
    local volume=
    local space=""
    local encrypted=
    local bind=
    for index in "${volumes[@]}"; do
        _copy "volume" "/volumes/${index}/name"
        STRING_SUBST "volume" "'" "" 1
        STRING_SUBST "volume" '"' "" 1
        _copy "type" "/volumes/${index}/type"
        STRING_SUBST "type" "'" "" 1
        STRING_SUBST "type" '"' "" 1
        # Check so type is recognized:
        if ! STRING_ITEM_INDEXOF "${valid_types}" "${type}"; then
            PRINT "Wrong type for volume ${volume}. Must be ramdisk, config, volume or host." "error" 0
            return 1
        fi

        if [[ ! $volume =~ ^[a-z]([_a-z0-9]*[a-z0-9])?$ ]]; then
            PRINT "Volume name '${volume}' is malformed. only lowercase letters [a-z], numbers [0-9] and underscore is allowed. First character must be lowercase letter" "error" 0
            return 1
        fi

        if [ "${type}" = "volume" ]; then
            # For all regular volumes we set the prefix
            volume="${volume}${volumesuffix}"
        fi

        # Check for duplicates
        if STRING_ITEM_INDEXOF "${all_volumes}" "${volume}"; then
            # Duplicate
            PRINT "Volume name ${volume} is already defined." "error" 0
            return 1
        fi

        _copy "encrypted" "/volumes/${index}/encrypted"
        STRING_SUBST "encrypted" "'" "" 1
        STRING_SUBST "encrypted" '"' "" 1
        _copy "bind" "/volumes/${index}/bind"
        STRING_SUBST "bind" "'" "" 1
        STRING_SUBST "bind" '"' "" 1

        if [ "${type}" = "ramdisk" ]; then
            local size=
            _copy "size" "/volumes/${index}/size"
            STRING_SUBST "size" "'" "" 1
            STRING_SUBST "size" '"' "" 1
            size="${size:-1M}"
            if [[ ! $size =~ ^[0-9]+M$ ]]; then
                PRINT "Ramdisk size must be in megabytes and followed by a capital M, such as: 2M" "error" 0
                return 1
            fi
            POD_RAMDISKS="${POD_RAMDISKS}${POD_RAMDISKS:+ }${volume}:${size}"
        elif [ "${type}" = "volume" ]; then
            POD_VOLUMES="${POD_VOLUMES}${POD_VOLUMES:+ }${volume}"
        elif [ "${type}" = "config" ]; then
            if [ ! -d "${buildDir}/config/${volume}" ]; then
                PRINT "Config '${volume}' does not exist as: ${buildDir}/config/${volume}." "error" 0
                return 1
            fi
            volumes_config="${volumes_config} ${volume}"
            volumes_config_encrypted="${volumes_config_encrypted} ${encrypted:-false}"
        elif [ "${type}" = "host" ]; then
            volumes_host="${volumes_host} ${volume}"
            bind="$(FILE_REALPATH "${bind}" "${srcDir}")"
            volumes_host_bind="${volumes_host_bind} ${bind}"
        fi

        # Check if encrypted config drive, if so then create matching ramdisk for it
        if [ -n "${encrypted}" ]; then
            if [ "${encrypted}" = "true" ]; then
                if [ "${type}" = "config" ]; then
                    # Create ramdisk, check so it doesn't exist already
                    local newramdisk="${volume}-unencrypted"
                    if STRING_ITEM_INDEXOF "${all_volumes}" "${newramdisk}"; then
                        # Duplicate
                        PRINT "Volume name ${newramdisk} is already defined." "error" 0
                        return 1
                    fi
                    all_volumes="${all_volumes}${space}${newramdisk}"

                    # Create decrypter container
                    local decrypterimage="simplenetes/secret-decrypter:1.0"
                    POD_CONTAINER_COUNT=$((POD_CONTAINER_COUNT+1))
                    eval "$(_CONTAINER_VARS "${POD_CONTAINER_COUNT}")"
                    local decryptername="${volume}-decrypter"
                    _CONTAINER_SET_VAR "${POD_CONTAINER_COUNT}" "NAME" "decryptername"
                    _CONTAINER_SET_VAR "${POD_CONTAINER_COUNT}" "IMAGE" "decrypterimage"
                    local v="on-config"
                    _CONTAINER_SET_VAR "${POD_CONTAINER_COUNT}" "RESTARTPOLICY" "v"
                    v="exit"
                    _CONTAINER_SET_VAR "${POD_CONTAINER_COUNT}" "STARTUPPROBE" "v"
                    v="120"
                    _CONTAINER_SET_VAR "${POD_CONTAINER_COUNT}" "STARTUPTIMEOUT" "v"
                    v="${volume}"
                    _CONTAINER_SET_VAR "${POD_CONTAINER_COUNT}" "CONFIGS" "v"
                    v="${volume}-unencrypted"
                    POD_RAMDISKS="${POD_RAMDISKS}${POD_RAMDISKS:+ }${v}:1M"
                    # Only this container should be able to access this config, hence the capital Z in :options.
                    local mounts="-v ./config/${volume}:/mnt/config:Z,ro -v ./ramdisk/${v}:/mnt/ramdisk:z:rw"
                    _CONTAINER_SET_VAR "${POD_CONTAINER_COUNT}" "MOUNTS" "mounts"
                    _COMPILE_RUN
                else
                    PRINT "Only config volumes can be encrypted" "error" 0
                    return 1
                fi
            elif [ "${encrypted}" != "false" ]; then
                PRINT "Unknown value for 'encrypted' for volume ${volume}, ignoring" "warning" 0
            fi
        fi

        all_volumes="${all_volumes}${space}${volume}"
        space=" "
    done

    # Go over all containers
    #

    local containers=()
    _list "containers" "/containers/"

    # Check all container names and check for duplicates.
    local container_names=""
    local index=
    for index in "${containers[@]}"; do
        local container_name=
        _copy "container_name" "/containers/${index}/name"
        STRING_SUBST "container_name" "'" "" 1
        STRING_SUBST "container_name" '"' "" 1
        if [[ ! $container_name  =~ ^[a-z]([_a-z0-9]*[a-z0-9])?$ ]]; then
            PRINT "Container name '${container_name}' is malformed. only lowercase letters [a-z], numbers [0-9] and underscore is allowed. First character must be lowercase letter" "error" 0
            return 1
        fi
        if STRING_ITEM_INDEXOF "${container_names}" "${container_name}"; then
            PRINT "Container name ${container_name} already defined, change the name." "error" 0
            return 1
        fi
        container_names="${container_names} ${container_name}"
    done

    local lines=()
    local value=
    for index in "${containers[@]}"; do
        POD_CONTAINER_COUNT=$((POD_CONTAINER_COUNT+1))
        eval "$(_CONTAINER_VARS "${POD_CONTAINER_COUNT}")"

        ## name
        #
        local container_name=
        _copy "container_name" "/containers/${index}/name"
        STRING_SUBST "container_name" "'" "" 1
        STRING_SUBST "container_name" '"' "" 1
        _CONTAINER_SET_VAR "${POD_CONTAINER_COUNT}" "NAME" "container_name"

        ## restart:
        #
        local value=""
        if ! _COMPILE_RESTART; then
            return 1
        fi
        _CONTAINER_SET_VAR "${POD_CONTAINER_COUNT}" "RESTARTPOLICY" "value"

        ## image:
        #
        local value=""
        if ! _COMPILE_IMAGE; then
            return 1
        fi
        _CONTAINER_SET_VAR "${POD_CONTAINER_COUNT}" "IMAGE" "value"

        ## signal:
        #
        local sig=""
        local cmd=""
        if ! _COMPILE_SIGNALEXEC; then
            return 1
        fi
        _CONTAINER_SET_VAR "${POD_CONTAINER_COUNT}" "SIGNALSIG" "sig"
        _CONTAINER_SET_VAR "${POD_CONTAINER_COUNT}" "SIGNALCMD" "cmd"

        ## startupProbe/timeout:
        #
        local value=""
        if ! _COMPILE_STARTUP_PROBE_TIMEOUT; then
            return 1
        fi
        _CONTAINER_SET_VAR "${POD_CONTAINER_COUNT}" "STARTUPTIMEOUT" "value"

        ## startupProbe/exit or startupProbe/cmd
        local value=""
        if ! _COMPILE_STARTUP_PROBE; then
            return 1
        fi
        _CONTAINER_SET_VAR "${POD_CONTAINER_COUNT}" "STARTUPPROBE" "value"

        ## startupProbe/signal
        #
        local value=""
        if ! _COMPILE_STARTUP_PROBE_SIGNAL; then
            return 1
        fi
        _CONTAINER_SET_VAR "${POD_CONTAINER_COUNT}" "STARTUPSIGNAL" "value"

        ## readinessProbe/timeout
        #
        local value=""
        if ! _COMPILE_READINESS_PROBE_TIMEOUT; then
            return 1
        fi
        _CONTAINER_SET_VAR "${POD_CONTAINER_COUNT}" "READINESSTIMEOUT" "value"

        ## livenessProbe/cmd
        #
        local value=""
        if ! _COMPILE_LIVENESS_PROBE; then
            return 1
        fi
        _CONTAINER_SET_VAR "${POD_CONTAINER_COUNT}" "LIVENESSPROBE" "value"

        ## livenessProbe/timeout
        #
        local value=""
        if ! _COMPILE_LIVENESS_PROBE_TIMEOUT; then
            return 1
        fi
        _CONTAINER_SET_VAR "${POD_CONTAINER_COUNT}" "LIVENESSTIMEOUT" "value"

        ## livenessProbe/cmd
        #
        local value=""
        if ! _COMPILE_READINESS_PROBE; then
            return 1
        fi
        _CONTAINER_SET_VAR "${POD_CONTAINER_COUNT}" "READINESSPROBE" "value"

        ## mounts:
        #
        local mounts=""
        if ! _COMPILE_MOUNTS; then
            return 1
        fi
        _CONTAINER_SET_VAR "${POD_CONTAINER_COUNT}" "MOUNTS" "mounts"

        ## env
        #
        local value=""
        if ! _COMPILE_ENV; then
            return 1
        fi
        _CONTAINER_SET_VAR "${POD_CONTAINER_COUNT}" "ENV" "value"

        ## ingress
        #
        local _out_container_ports=""
        if ! _COMPILE_INGRESS "/containers/${index}/expose/" "true"; then
            return 1
        fi
        _CONTAINER_SET_VAR "${POD_CONTAINER_COUNT}" "PORTS" "_out_container_ports"

        if !  _COMPILE_ENTRYPOINT; then
            return 1
        fi

        if !  _COMPILE_CPUMEM; then
            return 1
        fi

        if !  _COMPILE_RUN; then
            return 1
        fi
    done

    # Extract all labels.
    if ! _COMPILE_LABELS; then
        return 1
    fi

    ## Postfix
    # All STARTUPSIGNAL must be transformed to their number.
    local container_nr=
    for container_nr in $(seq 1 ${POD_CONTAINER_COUNT}); do
        local sendsignals=
        local sendsignals_nrs=""
        _GET_CONTAINER_VAR "${container_nr}" "STARTUPSIGNAL" "sendsignals"
        local targetcontainer=
        for targetcontainer in ${sendsignals}; do
            # Get the container nr for this name
            local nr=
            if ! nr="$(_GET_CONTAINER_NR "${targetcontainer}")"; then
                PRINT "Could not find container ${targetcontainer} referenced in startupProbe/signal." "error" 0
                return 1
            fi
            sendsignals_nrs="${sendsignals_nrs}${sendsignals_nrs:+ }${nr}"
        done
        # Overwrite with new string
        _CONTAINER_SET_VAR "${container_nr}" "STARTUPSIGNAL" "sendsignals_nrs"
    done

    ## Postfix
    # All container names must be suffixed with the podName-version
    for container_nr in $(seq 1 ${POD_CONTAINER_COUNT}); do
        local containername=
        _GET_CONTAINER_VAR "${container_nr}" "NAME" "containername"
        containername="${containername}-${POD}"
        # Overwrite with new string
        _CONTAINER_SET_VAR "${container_nr}" "NAME" "containername"
    done

    ## Output all generated variables
    local newline="
"
    local var=
    for var in POD POD_VERSION POD_LABELS POD_CREATE POD_VOLUMES POD_RAMDISKS POD_HOSTPORTS POD_CONTAINER_COUNT; do
        local value="${!var}"
        STRING_ESCAPE "value" '"'
        _out_pod="${_out_pod}${newline}$(printf "%s=\"%s\"\\n" "${var}" "${value}")"
    done

    local index=
    for index in $(seq 1 ${POD_CONTAINER_COUNT}); do
        for var in NAME RESTARTPOLICY IMAGE STARTUPPROBE STARTUPTIMEOUT STARTUPSIGNAL LIVENESSPROBE LIVENESSTIMEOUT READINESSPROBE READINESSTIMEOUT SIGNALSIG SIGNALCMD CONFIGS MOUNTS ENV COMMAND ARGS WORKINGDIR CPUMEM PORTS RUN; do
            local varname="POD_CONTAINER_${var}_${index}"
            local value="${!varname}"
            _out_pod="${_out_pod}${newline}$(printf "%s=\"%s\"\\n" "${varname}" "${value}")"
        done
        _out_pod="${_out_pod}${newline}"
    done

    ## Output rest of runtime template file
    _out_pod="${_out_pod}${newline}$(awk 'BEGIN {show=0} /^[^#]/ { show=1 } {if(show==1) {print}}' "${runtimePath}")"
}

_COMPILE_EXECUTABLE()
{
    local _SPACE_NAME="_COMPILE_EXECUTABLE"

    local podName="${1}"
    shift

    local podVersion="${1}"
    shift

    local srcDir="${1}"
    shift

    local outFile="${1}"
    shift

    local buildDir="${outFile%/*}"

    # Find out what file to copy as the `pod` executable.
    local executable=
    _copy "executable" "/executable/file"
    executable="${srcDir}/${executable}"
    executable="$(FILE_REALPATH "${executable}")"
    if [ ! -f "${executable}" ]; then
        PRINT "The executable file '${executable}' does not exist." "error" 0
        return 1
    fi

    # Declare variables populated by fn
    local _out_container_ports=""  # We don't use this here but the fn accesses it.
    local POD_HOSTPORTS=""  # We don't use this either, here.
    local POD_INGRESSCONF=""
    local POD_PROXYCONF=""
    if ! _COMPILE_INGRESS "/expose/" "false"; then
        return 1
    fi

    local portmappingsFile="${outFile}.portmappings.conf"
    # Make into dotfile
    portmappingsFile="${portmappingsFile%/*}/.${portmappingsFile##*/}"

    local ingressFile="${outFile}.ingress.conf"
    # Make into dotfile
    ingressFile="${ingressFile%/*}/.${ingressFile##*/}"

    if [ -n "${POD_PROXYCONF}" ]; then
        printf "%s\\n" "${POD_PROXYCONF}" >"${portmappingsFile}"
    else
        rm -f "${portmappingsFile}"
    fi
    if [ -n "${POD_INGRESSCONF}" ]; then
        printf "%s\\n" "${POD_INGRESSCONF}" >"${ingressFile}"
    else
        rm -f "${ingressFile}"
    fi

    # Copy the executable
    cp "${executable}" "${outFile}"
    chmod +x "${outFile}"
}

_COMPILE_ENV()
{
    local _SPACE_NAME="_COMPILE_ENV"
    local args=()
    _list "args" "/containers/${index}/env/" 1 1

    if [ "${#args[@]}" -gt 0 ]; then
        local arg=
        local subarg=
        local space=""
        for arg in "${args[@]}"; do
            _copy "subarg" "/containers/${index}/env/${arg}/name"
            STRING_SUBST "subarg" "'" "" 1
            STRING_SUBST "subarg" '"' "" 1
            if [[ ! $subarg =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]; then
                PRINT "Env variable name contains illegal characters: ${subarg}. a-zA-Z0-9_, ha sto start with a letter." "error" 0
                return 1
            fi
            local subarg2=
            _copy "subarg2" "/containers/${index}/env/${arg}/value"
            _QUOTE_ARG "subarg2"
            value="${value}${space}-e ${subarg}=${subarg2}"
            space=" "
        done
    fi
}

_COMPILE_MOUNTS()
{
    local _SPACE_NAME="_COMPILE_MOUNTS"
    local args=()
    _list "args" "/containers/${index}/mounts/"

    if [ "${#args[@]}" -gt 0 ]; then
        local arg=
        local dest=
        local volume=
        local indexof=
        for arg in "${args[@]}"; do
            _copy "dest" "/containers/${index}/mounts/${arg}/dest"
            STRING_SUBST "dest" "'" "" 1
            STRING_SUBST "dest" '"' "" 1
            # Check so valid destination path
            if [ "${dest#/}" = "${dest}" ]; then
                PRINT "Dest path in mount must start with a slash." "error" 0
                return 1
            fi

            _copy "volume" "/containers/${index}/mounts/${arg}/volume"
            STRING_SUBST "volume" "'" "" 1
            STRING_SUBST "volume" '"' "" 1
            # Check so volume exists and get the type
            local type=""
            local bind=""
            local encrypted=

                # Need to compare when stripped away the :size parameter from the diskname
                local isRamdisk=0
                local ramdisk=
                for ramdisk in ${POD_RAMDISKS}; do
                    local diskname="${ramdisk%:*}"
                    if [ "${diskname}" = "${volume}" ]; then
                        isRamdisk=1
                        break
                    fi
                done

                if STRING_ITEM_INDEXOF "${POD_VOLUMES}" "${volume}${volumesuffix}"; then
                    type="volume"
                    volume="${volume}${volumesuffix}"
                    mounts="${mounts}${mounts:+ }-v ${volume}:${dest}:z,rw"
                elif [ "${isRamdisk}" = "1" ]; then
                    type="ramdisk"
                    bind="./ramdisk/${volume}"
                    mounts="${mounts}${mounts:+ }-v ${bind}:${dest}:z,rw"
                elif STRING_ITEM_INDEXOF "${volumes_host}" "${volume}" "indexof"; then
                    type="host"
                    STRING_ITEM_GET "${volumes_host_bind}" "${indexof}" "bind"
                    # dev option so that we can mount devices.
                    mounts="${mounts}${mounts:+ }-v ${bind}:${dest}:z,rw,dev"
                elif STRING_ITEM_INDEXOF "${volumes_config}" "${volume}" "indexof"; then
                    type="config"
                    # Check if encrypted
                    STRING_ITEM_GET "${volumes_config_encrypted}" "${indexof}" "encrypted"
                    if [ "${encrypted}" = "true" ]; then
                        bind="./ramdisk/${volume}-unencrypted"
                        mounts="${mounts}${mounts:+ }-v ${bind}:${dest}:z,ro"

                        # Add to unencrypter container to signal this container
                        local container_nr=
                        local containername="${volume}-decrypter"
                        if ! container_nr="$(_GET_CONTAINER_NR "${containername}")"; then
                            PRINT "Could not find container ${containername}." "error" 0
                            return 1
                        fi
                        # Add this container name to the decrypter containers send signals value
                        local sendsignals=
                        _GET_CONTAINER_VAR "${container_nr}" "STARTUPSIGNAL" "sendsignals"
                        sendsignals="${sendsignals}${sendsignals:+ }${container_name}"
                        _CONTAINER_SET_VAR "${container_nr}" "STARTUPSIGNAL" "sendsignals"
                    else
                        bind="./config/${volume}"
                        mounts="${mounts}${mounts:+ }-v ${bind}:${dest}:z,ro"
                        local configs=
                        _GET_CONTAINER_VAR "${POD_CONTAINER_COUNT}" "CONFIGS" "configs"
                        configs="${configs}${configs:+ }${volume}"
                        _CONTAINER_SET_VAR "${POD_CONTAINER_COUNT}" "CONFIGS" "configs"
                    fi
                else
                    PRINT "Volume ${volume} is not defined." "error" 0
                    return 1
                fi
            done
    fi

}

_COMPILE_STARTUP_PROBE_SIGNAL()
{
    local _SPACE_NAME="_COMPILE_STARTUP_PROBE_SIGNAL"
    local args=()
    _list "args" "/containers/${index}/startupProbe/signal/"

    if [ "${#args[@]}" -gt 0 ]; then
        local arg=
        local containername=
        local space=""
        local container_nr=
        for arg in "${args[@]}"; do
            # Note: Don't have to check for validity here because
            # these names will be checked and mapped into nrs further down.
            _copy "containername" "/containers/${index}/startupProbe/signal/${arg}/container"
            STRING_SUBST "containername" "'" "" 1
            STRING_SUBST "containername" '"' "" 1
            value="${value}${space}${containername}"
            space=" "
        done
    fi
}

_COMPILE_STARTUP_PROBE()
{
    local _SPACE_NAME="_COMPILE_STARTUP_PROBE"
    _copy "value" "/containers/${index}/startupProbe/exit"
    STRING_SUBST "value" "'" "" 1
    STRING_SUBST "value" '"' "" 1
    local args=()
    _list "args" "/containers/${index}/startupProbe/cmd/" "" 1
    if [ "${value}" = "true" ] && [ "${#args[@]}" -gt 0 ]; then
        PRINT "Only startupProbe/exit or startupProbe/cmd can be defined, for container ${container_name}." "error" 0
        return 1
    fi

    if [ "${value}" = "true" ]; then
        value="exit"
        return
    else
        value=""
        if [ "${#args[@]}" -gt 0 ]; then
            local arg=
            local subarg=
            local space=""
            for arg in "${args[@]}"; do
                _copy "subarg" "/containers/${index}/startupProbe/cmd/${arg}"
                _QUOTE_ARG "subarg"
                value="${value}${space}${subarg}"
                space=" "
            done
        fi
    fi
}

_COMPILE_STARTUP_PROBE_TIMEOUT()
{
    local _SPACE_NAME="_COMPILE_STARTUP_PROBE_TIMEOUT"
    _copy "value" "/containers/${index}/startupProbe/timeout"
    STRING_SUBST "value" "'" "" 1
    STRING_SUBST "value" '"' "" 1
    value="${value:-120}"
    if [[ ! $value =~ ^[0-9]+$ ]]; then
        PRINT "Startup timeout for container ${container_name} must be an integer." "error" 0
        return 1
    fi
}

_COMPILE_READINESS_PROBE()
{
    local _SPACE_NAME="_COMPILE_READINESS_PROBE"
    local args=()
    _list "args" "/containers/${index}/readinessProbe/cmd/" "" 1
    value=""
    if [ "${#args[@]}" -gt 0 ]; then
        local arg=
        local subarg=
        local space=""
        for arg in "${args[@]}"; do
            _copy "subarg" "/containers/${index}/readinessProbe/cmd/${arg}"
            _QUOTE_ARG "subarg"
            value="${value}${space}${subarg}"
            space=" "
        done
    fi
}

_COMPILE_READINESS_PROBE_TIMEOUT()
{
    local _SPACE_NAME="_COMPILE_READINESS_PROBE_TIMEOUT"
    _copy "value" "/containers/${index}/readinessProbe/timeout"
    STRING_SUBST "value" "'" "" 1
    STRING_SUBST "value" '"' "" 1
    value="${value:-120}"
    if [[ ! $value =~ ^[0-9]+$ ]]; then
        PRINT "Readiness timeout for container ${container_name} must be an integer." "error" 0
        return 1
    fi
}

_COMPILE_LIVENESS_PROBE()
{
    local _SPACE_NAME="_COMPILE_LIVENESS_PROBE"
    local args=()
    _list "args" "/containers/${index}/livenessProbe/cmd/" "" 1
    value=""
    if [ "${#args[@]}" -gt 0 ]; then
        local arg=
        local subarg=
        local space=""
        for arg in "${args[@]}"; do
            _copy "subarg" "/containers/${index}/livenessProbe/cmd/${arg}"
            _QUOTE_ARG "subarg"
            value="${value}${space}${subarg}"
            space=" "
        done
    fi
}

_COMPILE_LIVENESS_PROBE_TIMEOUT()
{
    local _SPACE_NAME="_COMPILE_LIVENESS_PROBE_TIMEOUT"
    _copy "value" "/containers/${index}/livenessProbe/timeout"
    STRING_SUBST "value" "'" "" 1
    STRING_SUBST "value" '"' "" 1
    value="${value:-120}"
    if [[ ! $value =~ ^[0-9]+$ ]]; then
        PRINT "Liveness timeout for container ${container_name} must be an integer." "error" 0
        return 1
    fi
}

_COMPILE_SIGNALEXEC()
{
    local _SPACE_NAME="_COMPILE_SIGNALEXEC"
    local args=()
    _list "args" "/containers/${index}/signal/" "" 1
    if [ "${#args[@]}" -gt 1 ]; then
        PRINT "Only one of signal/sig and signal/cmd can be defined, for container ${container_name}." "error" 0
        return 1
    fi

    _copy "sig" "/containers/${index}/signal/0/sig"
    STRING_SUBST "sig" "'" "" 1
    STRING_SUBST "sig" '"' "" 1
    if [ -n "${sig}" ]; then
        return
    else
        _list "args" "/containers/${index}/signal/0/cmd/" "" 1
        if [ "${#args[@]}" -gt 0 ]; then
            local arg=
            local subarg=
            local space=""
            for arg in "${args[@]}"; do
                _copy "subarg" "/containers/${index}/signal/0/cmd/${arg}"
                _QUOTE_ARG "subarg"
                cmd="${cmd}${space}${subarg}"
                space=" "
            done
        fi
    fi
}

_COMPILE_IMAGE()
{
    local _SPACE_NAME="_COMPILE_IMAGE"
    _copy "value" "/containers/${index}/image"
    STRING_SUBST "value" "'" "" 1
    STRING_SUBST "value" '"' "" 1
    if [ -z "${value}" ]; then
        PRINT "Image for container ${container_name} is invalid." "error" 0
        return 1
    fi
}

_COMPILE_RESTART()
{
    local _SPACE_NAME="_COMPILE_RESTART"
    _copy "value" "/containers/${index}/restart"
    STRING_SUBST "value" "'" "" 1
    STRING_SUBST "value" '"' "" 1

    value="${value:-never}"
    local value2="${value%:*}"  # Cut away the :x for on-interval:x
    if [[ $value2 = "on-interval" ]] && [[ ! $value =~ ^on-interval:[0-9]+$ ]]; then
        PRINT "Restart policy on-interval must be on format on-interval:seconds" "error" 0
        return 1
    fi
    if ! STRING_ITEM_INDEXOF "always on-interval on-config on-failure never" "${value2}"; then
        PRINT "Restart policy '${value}' for container ${container_name} is invalid. Must be always, on-interval:x, on-config, on-failure or never." "error" 0
        return 1
    fi
}

STRING_ITEM_COUNT()
{
    local _SPACE_NAME="STRING_ITEM_COUNT"

    local __s="${1}"
    shift

    local __outvar="${1}"
    shift

    local __item=
    local __count=0
    for __item in ${__s}; do
        __count=$((__count+1))
    done
    eval "${__outvar}=\"\${__count}\""
}

YAML_PARSE_IMPL()
{
    local _SPACE_NAME="YAML_PARSE_IMPL"

    local _filepath=$1
    shift

    local _outvarname=$1
    shift

    # shellcheck disable=2034
    local _parsedyamlcompletion=()
    # shellcheck disable=2034
    local _parsedyaml=()
    local _yamlrows=()

    # shellcheck disable=2034
    IFS=$'\n' read -d '' -r -a _yamlrows < $_filepath

    # Store current locale settings
    local _unset_locale_flag=0
    local _stored_locale=
    if [ -z "${LC_ALL+unset}" ]; then
        _unset_locale_flag=1
    else
        _stored_locale="${LC_ALL}"
    fi
    # Set locale to get traditional sort order (bytes comparison)
    export LC_ALL="C"

    _parse_yaml "_yamlrows" "_parsedyaml" "_parsedyamlcompletion"
    _sort "_parsedyamlcompletion"
    eval "_parsedyamlnodelist${_YAML_PREFIX}${_YAML_NAMESPACE}=(\"\${_parsedyamlcompletion[@]}\")"
    _parsed_yaml_to_bash "_parsedyaml" "$_outvarname"

    # Restore locale settings to their original state
    if [ "${_unset_locale_flag}" -eq "1" ]; then
        unset LC_ALL
    else
        LC_ALL="${_stored_locale}"
    fi
}

_parse_yaml()
{
    local _SPACE_NAME="_parse_yaml"
    local _invarname=$1
    shift
    local _outvarname=$1
    shift
    local _outcompletionvarname=$1
    shift

    local _allrows=()
    eval "_allrows=(\"\${"${_invarname}"[@]}\")"

    local _numrows=${#_allrows[@]}
    local _rowindex=0
    local _lastindent=0
    local _nodes=("/")
    local _lastkey=""
    local _prefix="/"
    local _indent=0
    local _rowtype=
    local _key=
    local _readahead=()
    local _nextindent=0
    local _arrayextraindent=
    local _output=

    while _yaml_get_next 0;
    do
        # Set node prefix for changed indentation level.
        if (( _indent > _lastindent )); then
            # Increasing indentation level, add to prefix.
            _prefix=$_prefix$_lastkey\/
            _nodes[$_indent]=$_prefix
        elif (( _indent < _lastindent )); then
            # Decreasing indentation level, fallback to earlier prefix.
            _prefix=${_nodes[$_indent]}
        fi
        _lastindent=$_indent
        case "${_rowtype}" in
            leaf) # A regular key value row.
                local _varname=$_prefix$_key

                # Add to node name completion list.
                local _completionname="${_varname}/"
                local _item=
                # Break down the path and add each sub path as completion name, early quit when
                # a path is found since we are guaranteed all the remaining sub paths are already added.
                while :; do
                    eval '
                    for _item in "${'$_outcompletionvarname'[@]-}"; do
                        if [[ $_item == "${_completionname} 0" || $_item == "${_completionname} 1" ]]; then
                            break 2
                        fi
                    done
                    '
                    if [[ $_completionname == "${_varname}/" ]]; then
                        # The leaf node
                        eval "$_outcompletionvarname+=(\"${_completionname} 1\")"
                    else
                        eval "$_outcompletionvarname+=(\"${_completionname} 0\")"
                    fi
                    if [[ $_completionname == "/" ]]; then
                        break
                    fi
                    _completionname=${_completionname%/*/}/
                done
                unset _item
                unset _completionname

                _varname=${_varname//_/0a95}
                _varname=${_varname//\//_}
                if ((${#_readahead[@]} == 0)); then
                    # Simulate multiline value for the single line
                    if [[ ${value//\ } != "" ]]; then
                        _readahead[0]="$value"
                    else
                        _readahead[0]=""
                    fi
                else
                    # Check if to collapse new lines.
                    if [[ ${value:0:1} == ">" ]]; then
                        local _s=${_readahead[@]}
                        _readahead=("$_s")
                    fi
                fi
                eval "$_outvarname+=(\"\$_varname\")"
                local _line=
                for _line in "${_readahead[@]}"; do
                    printf -v _output "%s" "$_line"
                    eval "$_outvarname+=(\"\$_output\")"
                done
                eval "$_outvarname+=(\"\$_SPACEGAL_EOF_TAG\")"
                _lastkey=$_key
                ;;
            object) # Start of new object
                _lastkey=$_key
                ;;
            arrayobject)
                # New array object begins
                # Output key index at given indent
                local _i=$(( _indent + _arrayextraindent ))
                local _varname="_index_count${_prefix//\//_}"
                local _count=${!_varname-0}
                eval "local $_varname=$(( _count + 1 ))"
                local _subrows=()
                # Reinsert the key value of first line to have it handled as a normal leaf.
                if [[ -z $_key ]]; then
                    printf -v _output "%*s%s" $_i "" "$_count: $value"
                else
                    printf -v _output "%*s%s" $_i "" "$_key: $value"
                fi
                _subrows+=("$_output")
                if ((${#_readahead[@]} > 0)); then
                    ((_i+=4))
                    local _line=
                    for _line in "${_readahead[@]}"; do
                        printf -v _output "%*s%s" $_i "" "$_line"
                        _subrows+=("$_output")
                    done
                fi
                _allrows=("${_allrows[@]:0:$_rowindex}" "${_subrows[@]}" \
                    "${_allrows[@]:$_rowindex:$_numrows-$_rowindex}")
                ((_numrows+=${#_subrows[@]}))
                _lastkey=$_count
                ;;
        esac
    done
}

_yaml_get_next()
{
    local _SPACE_NAME="_yaml_get_next"
    if (( _rowindex >= _numrows )); then
        return 1
    fi

    local _dopreprocess=${1}
    shift

    # This particular preprocess value will have its substitution postponed because
    # we do not know the correct parent node already.
    local _PP_PARENT=_PP_PARENT
    local _PP_PARENTPATH=_PP_PARENTPATH

    local _row=
    _yaml_get_row $_rowindex $_dopreprocess
    ((_rowindex+=1))

    _key=""
    value=""
    _rowtype=""
    _readahead=()

    if [[ $_row =~ ^([\ ]*)(\@include)[\ ]*:(-?)[\ ]+(.*) ]]; then
        _indent=${#BASH_REMATCH[1]}
        _key=
        local _op=${BASH_REMATCH[3]}
        value=${BASH_REMATCH[4]}
        _includevariables=
        if [[ $value =~ ^(.*)[\ ]*\|[\ ]*(.*) ]]; then
            _includefile=${BASH_REMATCH[1]}
            local _s=${BASH_REMATCH[2]}
            if [[ $_s =~ (.*)\((.*)\)$ ]]; then
                _includefilter=${BASH_REMATCH[1]}
                _includevariables=${BASH_REMATCH[2]}
            else
                _includefilter=$_s
            fi
        else
            _includefile=$value
            _includefilter=""
        fi
        _yaml_get_multiline 0
        # Check if $_includefile is a module
        if [[ -n $_includefile && ! $_includefile =~ \.yaml$ ]]; then
            _module_find_yaml "$_includefile" "_includefile"
        fi
        if [[ $_op == "-" && ! -f $_includefile ]]; then
             # Ignore missing yaml file.
            _rowtype=""
        else
            _rowtype="include"
        fi
    elif [[ $_row =~ ^([\ ]*)(\@clone)[\ ]*:[\ ]+(.*) ]]; then
        _indent=${#BASH_REMATCH[1]}
        _key=
        value=${BASH_REMATCH[3]}
        _rowtype="clone"
    elif [[ $_row =~ ^([\ ]*)(\@debug)[\ ]*:[\ ]+(.*) ]]; then
        _indent=${#BASH_REMATCH[1]}
        _key=
        value=${BASH_REMATCH[3]}
        _rowtype="debug"
    elif [[ $_row =~ ^([\ ]*)(\@assert)[\ ]*:[\ ]+(.*) ]]; then
        _indent=${#BASH_REMATCH[1]}
        _key=
        value=${BASH_REMATCH[3]}
        _rowtype="assert"
    elif [[ $_row =~ ^([\ ]*)(\@cache)[\ ]*:[\ ]+(.*) ]]; then
        _indent=${#BASH_REMATCH[1]}
        _key=
        value=${BASH_REMATCH[3]}
        _rowtype="cache"
    elif [[ $_row =~ ^([\ ]*)(\@prompt)[\ ]*:(-?)[\ ]+([^\ ]+)[\ ](.*) ]]; then
        _indent=${#BASH_REMATCH[1]}
        local _op=${BASH_REMATCH[3]}
        _key=${BASH_REMATCH[4]}
        value=${BASH_REMATCH[5]}
        if [[ $_op == "-" ]]; then
            # @prompt:- means only prompt on variable if it lacks a value or is unset.
            local _pp_varname="_PP_$_key"
            if [[ -n ${!_pp_varname-} ]]; then
                return 0
            fi
        fi
        _rowtype="prompt"
    elif [[ $_row =~ ^([\ ]*)\@([a-zA-Z0-9_]+)[\ ]*(:|:-|:\+)\ (.*) ]]; then
        # Assign preprocess variable.
        _indent=${#BASH_REMATCH[1]}
        _key=${BASH_REMATCH[2]}
        local _op=${BASH_REMATCH[3]}
        if [[ $_op == ":-" ]]; then
            # @var:- means only assign variable if it lacks a value or is unset.
            local _pp_varname="_PP_$_key"
            if [[ -n ${!_pp_varname-} ]]; then
                return 0
            fi
        elif [[ $_op == ":+" ]]; then
            # @var:+ means only assign variable if it already has a value.
            local _pp_varname="_PP_$_key"
            if [[ -z ${!_pp_varname-} ]]; then
                return 0
            fi
        elif [[ $_op == ":" ]]; then
            # @var: means always assign to variable.
            # Fall through.
            :
        fi
        value=${BASH_REMATCH[4]}
        _rowtype="assign"
    elif [[ $_row =~ ^([\ ]*)\@([a-zA-Z0-9_]+)[\ ]*(:|:-|:\+)$ ]]; then
        # Unset a preprocess variable.
        _indent=${#BASH_REMATCH[1]}
        _key=${BASH_REMATCH[2]}
        local _op=${BASH_REMATCH[3]}
        if [[ $_op == ":-" ]]; then
            # @var:- means only unset variable if it lacks a value or is unset.
            local _pp_varname="_PP_$_key"
            if [[ -n ${!_pp_varname-} ]]; then
                return 0
            fi
        elif [[ $_op == ":+" ]]; then
            # @var:+ means only unset variable if it has a value.
            local _pp_varname="_PP_$_key"
            if [[ -z ${!_pp_varname-} ]]; then
                return 0
            fi
        elif [[ $_op == ":" ]]; then
            # @var: means always unset variable.
            # Fall through.
            :
        fi
        eval "unset _PP_$_key"
    elif [[ $_row =~ ^([\ ]*)([a-zA-Z0-9_]+)[\ ]*:[\ ]?(.*) ]]; then
        # Key value or new object/array row
        _indent=${#BASH_REMATCH[1]}
        _key=${BASH_REMATCH[2]}
        value=${BASH_REMATCH[3]}
        if [[ ${value//\ } != "" ]]; then
            # This row has a value (other than spaces)
            _rowtype="leaf"
            # Check if we should do a read ahead.
            if [[ ${value:0:1} == "|" || ${value:0:1} == ">" ]]; then
                _yaml_get_multiline $_dopreprocess
            fi
        else
            value=""
            # This node has no value, we must figure out if it's
            # an empty leaf or an object.

            # Find out the nextindent level for an object row.
            local _yamlindent=0
            _yaml_find_nextindent
            if (( _yamlindent > _indent )); then
                _rowtype="object"
            else
                _rowtype="leaf"
            fi
            unset _yamlindent
        fi
    elif [[ $_row =~ ^([\ ]*)\-([\ ]+)([a-zA-Z0-9_]+)[\ ]*:[\ ]+(.*) ||
             $_row =~ ^([\ ]*)\-([\ ]+)([a-zA-Z0-9_]+)[\ ]*:($) ]]; then
        # Array item with child object.
        _indent=${#BASH_REMATCH[1]}
        _arrayextraindent=$((${#BASH_REMATCH[2]}+1))
        _key=${BASH_REMATCH[3]}
        value=${BASH_REMATCH[4]}
        _rowtype="arrayobject"
        if [[ ${value//\ } != "" ]]; then
            # This row has a value (other than spaces)
            # Check if we should do a read ahead.
            if [[ ${value:0:1} == "|" || ${value:0:1} == ">" ]]; then
                _yaml_get_multiline $_dopreprocess
            fi
        fi
    elif [[ $_row =~ ^([\ ]*)\-[\ ]+(.*) || $_row =~ ^([\ ]*)\-($) ]]; then
        # Array index item with only value.
        _indent=${#BASH_REMATCH[1]}
        _arrayextraindent=0
        _key=
        value=${BASH_REMATCH[2]}
        _rowtype="arrayobject"
        if [[ ${value//\ } != "" ]]; then
            # This row has a value (other than spaces)
            # Check if we should do a read ahead.
            if [[ ${value:0:1} == "|" || ${value:0:1} == ">" ]]; then
                _yaml_get_multiline $_dopreprocess
            fi
        fi
    else
        # Unknown row
        :
    fi
    return 0
}

_yaml_get_row()
{
    local _SPACE_NAME="_yaml_get_row"
    local _index=$1
    shift
    local _dopreprocess=$1
    shift

    _row=${_allrows[$_index]}
    while [[ $_dopreprocess == "1" && $_row =~ ^(.*)\@\{([\ @a-zA-Z0-9_:-]+)\}(.*)$ ]]; do
        # Substitute preprocessed variable
        local _left=${BASH_REMATCH[1]}
        local _s=${BASH_REMATCH[2]}
        local _right=${BASH_REMATCH[3]}
        if [[ $_s =~ ([a-zA-Z0-9_]+)(:?\-)(.+) ]]; then
            local _substvar=_PP_${BASH_REMATCH[1]}
            local _op=${BASH_REMATCH[2]}
            local _substvar2=${BASH_REMATCH[3]}
            if [[ ${_substvar2:0:1} == "@" ]]; then
                _substvar2=_PP_${_substvar2:1}
                local _substvalue2=${!_substvar2-}
            else
                local _substvalue2=$_substvar2
            fi
            local _substvalue=
            if [[ $_op == "-" ]]; then
                _substvalue=${!_substvar-$_substvalue2}
            else
                _substvalue=${!_substvar:-$_substvalue2}
            fi
        else
            local _substvar=_PP_$_s
            local _substvalue=${!_substvar-}
        fi

        _row=${_left}${_substvalue}${_right}
    done
}

_yaml_get_multiline()
{
    local _SPACE_NAME="_yaml_get_multiline"
    local _dopreprocess=$1
    shift

    if (( _rowindex >= _numrows )); then
        return
    fi
    local _row=
    _yaml_get_row $_rowindex $_dopreprocess
    if [[ $_row =~ ^([\ ]+)([^\ ].*) ]]; then
        local _subindent=${#BASH_REMATCH[1]}
        local _subvalue=${BASH_REMATCH[2]}
        if (( _subindent > _indent )); then
            _readahead+=("$_subvalue")
            while :; do
                ((_rowindex+=1))
                if (( _rowindex >= _numrows )); then
                    break
                fi
                _yaml_get_row $_rowindex $_dopreprocess
                if [[ $_row =~ ^([\ ]+)([^\ ].*) || $_row =~ ^([\ ]{$_subindent})(.*) ]]; then
                    local _subindent2=${#BASH_REMATCH[1]}
                    if (( _subindent2 < _subindent )); then
                        break
                    fi
                    printf -v _subvalue "%*s%s" $(( _subindent2 - _subindent)) "" \
                        "${BASH_REMATCH[2]}"
                    _readahead+=("$_subvalue")
                else
                    break
                fi
            done
        fi
    fi
}

_parsed_yaml_to_bash()
{
    local _SPACE_NAME="_parsed_yaml_to_bash"
    local _invarname=$1
    shift

    local _outvarname=$1
    shift

    local _allrows=()
    eval "_allrows=(\"\${"${_invarname}"[@]}\")"

    local _line=
    local _str=
    local _varname=
    for _line in "${_allrows[@]}"; do
        if [[ -z $_varname ]]; then
            _varname="${_YAML_PREFIX}${_YAML_NAMESPACE}${_line}"
            _str="local $_varname="$'\n'" read -d '' -r $_varname << \"$_SPACEGAL_EOF_TAG\""
        elif [[ $_line == "$_SPACEGAL_EOF_TAG" ]]; then
            _str=$_str$'\n'$_SPACEGAL_EOF_TAG$'\n'":"$'\n'
            eval "$_outvarname+=(\"\$_str\")"
            _str=""
            _varname=
        else
            _str=$_str$'\n'$_line
        fi
    done
}

_sort()
{
    local _SPACE_NAME="_sort"
    local _arrname=$1
    shift

    eval "local _last=\${#${_arrname}[@]}"
    ((_last-=1))
    local _i=
    for (( ; _last>0; _last-- )); do
        for (( _i=0; _i<_last; _i++ )); do
            eval "local _line1=\${${_arrname}[$_i]}"
            eval "local _line2=\${${_arrname}[$((_i+1))]}"
            local _line1padded=
            local _line2padded=
            # shellcheck disable=2154
            _sort_pad "_line1padded" "$_line1"
            # shellcheck disable=2154
            _sort_pad "_line2padded" "$_line2"
            if [[ "${_line1padded}" > "${_line2padded}" ]]; then
                eval "${_arrname}[$_i]=\"$_line2\""
                eval "${_arrname}[$((_i+1))]=\"$_line1\""
            fi
        done
    done
}

_sort_pad()
{
    local _SPACE_NAME="_sort_pad"
    local _output=$1
    shift

    local _s=$1
    shift

    local _s2="" _tmp=""
    while [[ $_s =~ ([^0-9.]*)([0-9]+)(.*) ]]; do
        printf -v _tmp "%010d" ${BASH_REMATCH[2]}
        _s2=$_s2${BASH_REMATCH[1]}$_tmp
        _s=${BASH_REMATCH[3]}
    done
    _s2=$_s2$_s
    eval "$_output=\$_s2"
}

_yaml_find_nextindent()
{
    local _SPACE_NAME="_yaml_find_nextindent"
    local _i=$_rowindex
    _nextindent=4  # Default value
    _yamlindent=0

    while :; do
        if (( _i >= _numrows )); then
            return
        fi
        local _peekrow=${_allrows[$_i]}
        ((_i+=1))
        if [[ $_peekrow =~ ^([\ ]*)\-([\ ]+)[a-zA-Z0-9_]+[\ ]*:[\ ]*.* ]]; then
            _yamlindent=$((${#BASH_REMATCH[1]}+${#BASH_REMATCH[2]}+1))
            break
        elif [[ $_peekrow =~ ^([\ ]*)([a-zA-Z0-9_@]+)[\ ]*:[\ ]*(.*) ]]; then
            _yamlindent=${#BASH_REMATCH[1]}
            break
        elif [[ $_peekrow =~ ^([\ ]*)\-[\ ]*$ ]]; then
            _yamlindent=$((${#BASH_REMATCH[1]}))
            break
        fi
    done
    if [[ $_yamlindent -gt $_indent ]]; then
        _nextindent=$(( _yamlindent - _indent))
    fi
}

_list()
{
    local _SPACE_NAME="_list"

    local _output=$1
    shift

    local _path=$1
    shift

    local _includehidden=${1:-0}
    shift || :

    local _includeleafs=${1:-0}
    shift || :

    if [[ ! $_path =~ (^/.+/$)|(^/$) ]]; then
        PRINT "Malformed path ($_path) as argument to _list. Must start and end with a slash. Lonesome cowboy slashes are OK though." "error" 0
        return 1
    fi

    local _nodes=()
    _match_node "_parsedyamlnodelist${_YAML_PREFIX}${_YAML_NAMESPACE}" "${_path}.*/" "${_includehidden}" "1" "${_includeleafs}"
    if (( ${#_nodes[@]} == 0 )); then
        eval "${_output}=()"
    else
        eval "${_output}=(\"\${_nodes[@]}\")"
    fi
}

_copy()
{
    local _SPACE_NAME="_copy"
    local _var=$1
    shift

    local _path=${1//_/0a95}
    shift

    _path="${_YAML_PREFIX}${_YAML_NAMESPACE}${_path//\//_}"
    eval "$_var=\${$_path-}"
}

_match_node()
{
    local _SPACE_NAME="_match_node"
    local _inputname=$1
    shift

    local _nodepath=$1
    shift

    local _includehidden=${1:-0}
    shift || :

    local _simple=${1:-0}
    shift || :

    local _includeleafs=${1:-0}
    shift || :

    local _item=
    # shellcheck disable=2034
    local _node=
    # shellcheck disable=2034
    local _isleaf=
    local _nodelist=()
    eval '
    for _item in "${'$_inputname'[@]-}"; do
        if [[ $_item =~ ([^ ]+)\ (.*) ]]; then
            _node=${BASH_REMATCH[1]}
            _isleaf=${BASH_REMATCH[2]}
            if [[ ($_isleaf == "1" && $_includeleafs == "1") || $_isleaf == "0" ]]; then
                _nodelist+=($_node)
            fi
        fi
    done
    '
    unset _item _node _isleaf

    if ((${#_nodelist[@]} == 0)); then
        return 0
    fi

    local _item=
    local _levels=
    local _match=
    local _matched=

    # Figure out how many levels we have by counting slashes.
    _levels=${_nodepath//[^\/]}
    _levels=${#_levels}
    ((_levels-=1))
    if (( _levels == 0 )); then
        _nodes+=("/")
    else
        _match=""
        for ((i=0; i < _levels; i++)); do
            if ((i < _levels-1)) || [[ $_includehidden == "1" ]]; then
                _match="${_match}/[a-zA-Z0-9_]+"
            else
                _match="${_match}/[a-zA-Z0-9][a-zA-Z0-9_]*"
            fi
        done
        _match="${_match}/"
        for _item in "${_nodelist[@]}"; do
            if [[ $_item =~ ^($_match)$ ]]; then
                _matched=${BASH_REMATCH[1]}
                if [[ $_matched =~ $_nodepath ]]; then
                    if [[ $_simple == "0" ]]; then
                        _nodes+=("$_matched")
                    else
                        local _arr=()
                        IFS='/' read -r -a _arr <<< "${_matched}"
                        _nodes+=("${_arr[$((${#_arr[@]}-1))]}")
                        unset _arr
                    fi
                fi
            fi
        done
    fi
    unset _item _levels
    unset _match _matched
    unset _nodepath
}

_module_find_yaml()
{
    local _SPACE_NAME="_module_find_yaml"
    local _module=$1
    shift

    local _outvarname=$1
    shift

    local _domainname=""
    local _username="space-sh"
    local _reponame=$_module
    if [[ $_module =~ (.+)/(.+)/(.+) ]]; then
        _domainname=${BASH_REMATCH[1]}
        _username=${BASH_REMATCH[2]}
        _reponame=${BASH_REMATCH[3]}
    elif [[ $_module =~ (.+)/(.+) ]]; then
        _username=${BASH_REMATCH[1]}
        _reponame=${BASH_REMATCH[2]}
    fi
    #[[ $_reponame =~ ([^:]+) ]]
    #local _reponameclean=${BASH_REMATCH[1]}
    unset _module

    if [ "${_domainname}" = "" ]; then
        if [ "${_username}" = "space-sh" ]; then
            _domainname="gitlab.com"
        fi
    fi

    local _dir=
    local _f=
    for _dir in ${_INCLUDEPATH[@]}; do
        for _f in "$_dir/$_domainname/$_username/$_reponame/Spacefile.yaml"; do
            if [[ -f $_f ]]; then
                _debug "Found module $_f"
                eval "$_outvarname=\$_f"
                return
            fi
        done
    done
}

STRING_IS_ALL()
{
    local _SPACE_NAME="STRING_IS_ALL"

    local __str="${1}"
    shift

    local __pattern="${1}"
    shift

    local __m="[!${__pattern}]"
    case "${__str}" in
        (*${__m}*)
            return 1
            ;;
        *)
            ;;
    esac
}

main()
{
    PODC_CMDLINE "$@"

    # Space will print exit status.
    local _status=$?
    if [ "${_status}" -ne "${SPACE_ASSERT_EXIT}" ]; then
        if [ "${SPACE_MUTE_EXIT_MESSAGE}" != "1" ] && [ "${SPACE_LOG_LEVEL}" -ge 1 ]; then
            [ "${SPACE_LOG_ENABLE_COLORS:-1}" = "1" ] && [ -t 2 ] && printf "\033[31m" >&2
            printf "%s\n" "[ERROR] Script exited with status $_status for node /cmdline/" >&2
            [ "${SPACE_LOG_ENABLE_COLORS:-1}" = "1" ] && [ -t 2 ] && printf "\033[0m" >&2
        fi
        if [ "${SPACE_MUTE_EXIT}" != 1 ]; then
            return $((SPACE_ASSERT_EXIT == 0 ? _status : 1))
        fi
    elif [ "${SPACE_MUTE_EXIT_MESSAGE}" != "1" ] && [ "${SPACE_LOG_LEVEL}" -ge 5 ]; then
        [ "${SPACE_LOG_ENABLE_COLORS:-1}" = "1" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf "\033[32m" >&2
        printf "%s\n" "[DEBUG] Script exited with success (status $_status) for node /cmdline/" >&2
        [ "${SPACE_LOG_ENABLE_COLORS:-1}" = "1" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf "\033[0m" >&2
        : # Important to reset status here.
    fi
}

main "$@"
